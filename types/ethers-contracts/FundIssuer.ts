/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export interface FundIssuerInterface extends utils.Interface {
  functions: {
    "canImplementInterfaceForAddress(bytes32,address)": FunctionFragment;
    "canReceive(bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
    "tokensReceived(bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
    "setAssetRules(address,bytes32,uint256,uint256,uint256,uint256,uint8,address,bytes32,address,bool)": FunctionFragment;
    "setAssetValueRules(address,bytes32,uint8,uint256,uint256)": FunctionFragment;
    "subscribe(address,bytes32,uint256,uint256,uint8,bool)": FunctionFragment;
    "cancelOrder(uint256)": FunctionFragment;
    "rejectOrder(uint256,bool)": FunctionFragment;
    "valuate(uint256,uint256,uint256)": FunctionFragment;
    "executePaymentAsInvestor(uint256)": FunctionFragment;
    "executePaymentAsController(uint256,bool)": FunctionFragment;
    "batchExecutePaymentsAsController(uint256[],bool)": FunctionFragment;
    "batchSettleOrders(uint256[])": FunctionFragment;
    "finalizeCycle(uint256)": FunctionFragment;
    "getTotalSettledForCycle(uint256)": FunctionFragment;
    "getCycleState(uint256)": FunctionFragment;
    "tokenControllers(address)": FunctionFragment;
    "setTokenControllers(address,address[])": FunctionFragment;
    "priceOracles(address)": FunctionFragment;
    "setPriceOracles(address,address[])": FunctionFragment;
    "getAssetRules(address,bytes32)": FunctionFragment;
    "getAssetValueRules(address,bytes32)": FunctionFragment;
    "getNbCycles()": FunctionFragment;
    "getLastCycleIndex(address,bytes32)": FunctionFragment;
    "getCycle(uint256)": FunctionFragment;
    "getCycleAssetValue(uint256)": FunctionFragment;
    "getNbOrders()": FunctionFragment;
    "getOrder(uint256)": FunctionFragment;
    "getOrderAmountAndValue(uint256)": FunctionFragment;
    "getCycleOrders(uint256)": FunctionFragment;
    "getInvestorOrders(address)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "canImplementInterfaceForAddress",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "canReceive",
    values: [
      BytesLike,
      BytesLike,
      string,
      string,
      string,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensReceived",
    values: [
      BytesLike,
      BytesLike,
      string,
      string,
      string,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetRules",
    values: [
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string,
      BytesLike,
      string,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetValueRules",
    values: [string, BytesLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "subscribe",
    values: [
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "rejectOrder",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "valuate",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executePaymentAsInvestor",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executePaymentAsController",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "batchExecutePaymentsAsController",
    values: [BigNumberish[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "batchSettleOrders",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeCycle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalSettledForCycle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycleState",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenControllers",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenControllers",
    values: [string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "priceOracles",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOracles",
    values: [string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetRules",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetValueRules",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getNbCycles",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLastCycleIndex",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycleAssetValue",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getNbOrders",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOrder",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getOrderAmountAndValue",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycleOrders",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getInvestorOrders",
    values: [string]
  ): string;

  decodeFunctionResult(
    functionFragment: "canImplementInterfaceForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "canReceive", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokensReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetValueRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "subscribe", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rejectOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "valuate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executePaymentAsInvestor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executePaymentAsController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchExecutePaymentsAsController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchSettleOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeCycle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalSettledForCycle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCycleState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenControllers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenControllers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAssetRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAssetValueRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNbCycles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastCycleIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getCycle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCycleAssetValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNbOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getOrderAmountAndValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCycleOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInvestorOrders",
    data: BytesLike
  ): Result;

  events: {};
}

export interface FundIssuer extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: FundIssuerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    /**
     * Indicate whether or not the fund issuance contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (1/2)]
     * @param data Information attached to the token transfer.
     * @param operatorData Information attached to the Swaps transfer, by the operator.
     */
    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Hook function executed when tokens are sent to the fund issuance contract. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (2/2)]
     * @param data Information attached to the token transfer.
     * @param from Token holder.
     * @param operatorData Information attached to the Swaps transfer, by the operator.
     * @param partition Name of the partition.
     * @param to Token recipient.
     * @param value Number of tokens to transfer.
     */
    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Start a new subscription for a given asset in the fund issuance smart contract.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param paymentAddress Address of the payment token (only used id paymentType <> OFFCHAIN).
     * @param paymentPartition Partition of the payment token (only used if paymentType is ERC1400).
     * @param paymentPeriodLength Length of payment period.
     * @param paymentType Type of payment (OFFCHAIN | ERC20 | ERC1400).
     * @param subscriptionPeriodLength Length of subscription period.
     * @param subscriptionsOpened Set 'true' if subscriptions are opened, 'false' if not.
     * @param valuationPeriodLength Length of valuation period.
     */
    setAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: string,
      paymentPartition: BytesLike,
      fundAddress: string,
      subscriptionsOpened: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set asset value rules for a given asset.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param assetValue Asset value.
     * @param assetValueType Asset value type.
     * @param reverseAssetValue Reverse asset value.
     */
    setAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Subscribe for a given asset, by creating an order.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param orderAmount Amount of assets to purchase (used in case order type is 'amount').
     * @param orderType Order type (value | amount).
     * @param orderValue Value of assets to purchase (used in case order type is 'value').
     */
    subscribe(
      assetAddress: string,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Cancel an order.
     * @param orderIndex Index of the order to cancel.
     */
    cancelOrder(
      orderIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Reject an order.
     * @param orderIndex Index of the order to reject.
     * @param rejected Set to 'true' if order shall be rejected, and set to 'false' if rejection shall be cancelled
     */
    rejectOrder(
      orderIndex: BigNumberish,
      rejected: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set assetValue for a given asset.
     * @param assetValue Units of cash required for a unit of asset.
     * @param cycleIndex Index of the cycle where assetValue needs to be set.
     * @param reverseAssetValue Units of asset required for a unit of cash.
     */
    valuate(
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Execute payment for a given order.
     * @param orderIndex Index of the order to declare as paid.
     */
    executePaymentAsInvestor(
      orderIndex: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set payment as executed for a given order.
     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
     * @param orderIndex Index of the order to declare as paid.
     */
    executePaymentAsController(
      orderIndex: BigNumberish,
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set payments as executed for a batch of given orders.
     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
     * @param orderIndexes Indexes of the orders to declare as paid.
     */
    batchExecutePaymentsAsController(
      orderIndexes: BigNumberish[],
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Settle a batch of given orders.
     * @param orderIndexes Indexes of the orders to settle.
     */
    batchSettleOrders(
      orderIndexes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Finalize a given cycle.
     * @param cycleIndex Index of the cycle to finalize.
     */
    finalizeCycle(
      cycleIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Retrieve sum of paid/unpaid settled orders for a given cycle.
     * @param cycleIndex Index of the cycle.
     */
    getTotalSettledForCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber, boolean]>;

    /**
     * Retrieve the current state of the cycle.
     * @param cycleIndex Index of the cycle.
     */
    getCycleState(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number]>;

    /**
     * Get the list of token controllers for a given token.
     * @param tokenAddress Token address.
     */
    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Set list of token controllers for a given token.
     * @param operators Operators addresses.
     * @param tokenAddress Token address.
     */
    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the list of price oracles for a given token.
     * @param tokenAddress Token address.
     */
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    /**
     * Set list of price oracles for a given token.
     * @param oracles Oracles addresses.
     * @param tokenAddress Token address.
     */
    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get asset rules.
     * @param assetAddress Address of the asset.
     * @param assetClass Class of the asset.
     */
    getAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        string,
        string,
        string,
        boolean
      ]
    >;

    /**
     * Get the cycle asset value rules.
     * @param assetAddress Address of the asset.
     * @param assetClass Class of the asset.
     */
    getAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber, BigNumber]>;

    /**
     * Get total number of cycles in the contract.
     */
    getNbCycles(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Get the index of the last cycle created for a given asset class.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     */
    getLastCycleIndex(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Get the cycle.
     * @param index Index of the cycle.
     */
    getCycle(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        string,
        string,
        boolean
      ]
    >;

    /**
     * Get the cycle asset value.
     * @param index Index of the cycle.
     */
    getCycleAssetValue(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber, BigNumber]>;

    /**
     * Get total number of orders in the contract.
     */
    getNbOrders(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Retrieve an order.
     * @param index Index of the order.
     */
    getOrder(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, string, BigNumber, BigNumber, number, number]>;

    /**
     * Retrieve order amount and order value calculated based on cycle valuation.
     * @param orderIndex Index of the order.
     */
    getOrderAmountAndValue(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    /**
     * Get list of cycle orders.
     * @param index Index of the cycle.
     */
    getCycleOrders(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    /**
     * Get list of investor orders.
     */
    getInvestorOrders(
      investor: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;
  };

  canImplementInterfaceForAddress(
    interfaceHash: BytesLike,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Indicate whether or not the fund issuance contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
   * [ERC1400TokensRecipient INTERFACE (1/2)]
   * @param data Information attached to the token transfer.
   * @param operatorData Information attached to the Swaps transfer, by the operator.
   */
  canReceive(
    arg0: BytesLike,
    arg1: BytesLike,
    arg2: string,
    arg3: string,
    arg4: string,
    arg5: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Hook function executed when tokens are sent to the fund issuance contract. [USED FOR ERC1400 TOKENS ONLY]
   * [ERC1400TokensRecipient INTERFACE (2/2)]
   * @param data Information attached to the token transfer.
   * @param from Token holder.
   * @param operatorData Information attached to the Swaps transfer, by the operator.
   * @param partition Name of the partition.
   * @param to Token recipient.
   * @param value Number of tokens to transfer.
   */
  tokensReceived(
    arg0: BytesLike,
    partition: BytesLike,
    arg2: string,
    from: string,
    to: string,
    value: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Start a new subscription for a given asset in the fund issuance smart contract.
   * @param assetAddress Address of the token representing the asset.
   * @param assetClass Asset class.
   * @param paymentAddress Address of the payment token (only used id paymentType <> OFFCHAIN).
   * @param paymentPartition Partition of the payment token (only used if paymentType is ERC1400).
   * @param paymentPeriodLength Length of payment period.
   * @param paymentType Type of payment (OFFCHAIN | ERC20 | ERC1400).
   * @param subscriptionPeriodLength Length of subscription period.
   * @param subscriptionsOpened Set 'true' if subscriptions are opened, 'false' if not.
   * @param valuationPeriodLength Length of valuation period.
   */
  setAssetRules(
    assetAddress: string,
    assetClass: BytesLike,
    firstStartTime: BigNumberish,
    subscriptionPeriodLength: BigNumberish,
    valuationPeriodLength: BigNumberish,
    paymentPeriodLength: BigNumberish,
    paymentType: BigNumberish,
    paymentAddress: string,
    paymentPartition: BytesLike,
    fundAddress: string,
    subscriptionsOpened: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set asset value rules for a given asset.
   * @param assetAddress Address of the token representing the asset.
   * @param assetClass Asset class.
   * @param assetValue Asset value.
   * @param assetValueType Asset value type.
   * @param reverseAssetValue Reverse asset value.
   */
  setAssetValueRules(
    assetAddress: string,
    assetClass: BytesLike,
    assetValueType: BigNumberish,
    assetValue: BigNumberish,
    reverseAssetValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Subscribe for a given asset, by creating an order.
   * @param assetAddress Address of the token representing the asset.
   * @param assetClass Asset class.
   * @param orderAmount Amount of assets to purchase (used in case order type is 'amount').
   * @param orderType Order type (value | amount).
   * @param orderValue Value of assets to purchase (used in case order type is 'value').
   */
  subscribe(
    assetAddress: string,
    assetClass: BytesLike,
    orderValue: BigNumberish,
    orderAmount: BigNumberish,
    orderType: BigNumberish,
    executePaymentAtSubscription: boolean,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Cancel an order.
   * @param orderIndex Index of the order to cancel.
   */
  cancelOrder(
    orderIndex: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Reject an order.
   * @param orderIndex Index of the order to reject.
   * @param rejected Set to 'true' if order shall be rejected, and set to 'false' if rejection shall be cancelled
   */
  rejectOrder(
    orderIndex: BigNumberish,
    rejected: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set assetValue for a given asset.
   * @param assetValue Units of cash required for a unit of asset.
   * @param cycleIndex Index of the cycle where assetValue needs to be set.
   * @param reverseAssetValue Units of asset required for a unit of cash.
   */
  valuate(
    cycleIndex: BigNumberish,
    assetValue: BigNumberish,
    reverseAssetValue: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Execute payment for a given order.
   * @param orderIndex Index of the order to declare as paid.
   */
  executePaymentAsInvestor(
    orderIndex: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set payment as executed for a given order.
   * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
   * @param orderIndex Index of the order to declare as paid.
   */
  executePaymentAsController(
    orderIndex: BigNumberish,
    bypassPayment: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set payments as executed for a batch of given orders.
   * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
   * @param orderIndexes Indexes of the orders to declare as paid.
   */
  batchExecutePaymentsAsController(
    orderIndexes: BigNumberish[],
    bypassPayment: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Settle a batch of given orders.
   * @param orderIndexes Indexes of the orders to settle.
   */
  batchSettleOrders(
    orderIndexes: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Finalize a given cycle.
   * @param cycleIndex Index of the cycle to finalize.
   */
  finalizeCycle(
    cycleIndex: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Retrieve sum of paid/unpaid settled orders for a given cycle.
   * @param cycleIndex Index of the cycle.
   */
  getTotalSettledForCycle(
    cycleIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber, boolean]>;

  /**
   * Retrieve the current state of the cycle.
   * @param cycleIndex Index of the cycle.
   */
  getCycleState(
    cycleIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * Get the list of token controllers for a given token.
   * @param tokenAddress Token address.
   */
  tokenControllers(
    tokenAddress: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Set list of token controllers for a given token.
   * @param operators Operators addresses.
   * @param tokenAddress Token address.
   */
  setTokenControllers(
    tokenAddress: string,
    operators: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the list of price oracles for a given token.
   * @param tokenAddress Token address.
   */
  priceOracles(
    tokenAddress: string,
    overrides?: CallOverrides
  ): Promise<string[]>;

  /**
   * Set list of price oracles for a given token.
   * @param oracles Oracles addresses.
   * @param tokenAddress Token address.
   */
  setPriceOracles(
    tokenAddress: string,
    oracles: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get asset rules.
   * @param assetAddress Address of the asset.
   * @param assetClass Class of the asset.
   */
  getAssetRules(
    assetAddress: string,
    assetClass: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      string,
      string,
      string,
      boolean
    ]
  >;

  /**
   * Get the cycle asset value rules.
   * @param assetAddress Address of the asset.
   * @param assetClass Class of the asset.
   */
  getAssetValueRules(
    assetAddress: string,
    assetClass: BytesLike,
    overrides?: CallOverrides
  ): Promise<[number, BigNumber, BigNumber]>;

  /**
   * Get total number of cycles in the contract.
   */
  getNbCycles(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the index of the last cycle created for a given asset class.
   * @param assetAddress Address of the token representing the asset.
   * @param assetClass Asset class.
   */
  getLastCycleIndex(
    assetAddress: string,
    assetClass: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the cycle.
   * @param index Index of the cycle.
   */
  getCycle(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      number,
      string,
      string,
      boolean
    ]
  >;

  /**
   * Get the cycle asset value.
   * @param index Index of the cycle.
   */
  getCycleAssetValue(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[number, BigNumber, BigNumber]>;

  /**
   * Get total number of orders in the contract.
   */
  getNbOrders(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Retrieve an order.
   * @param index Index of the order.
   */
  getOrder(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[BigNumber, string, BigNumber, BigNumber, number, number]>;

  /**
   * Retrieve order amount and order value calculated based on cycle valuation.
   * @param orderIndex Index of the order.
   */
  getOrderAmountAndValue(
    orderIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber]>;

  /**
   * Get list of cycle orders.
   * @param index Index of the cycle.
   */
  getCycleOrders(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  /**
   * Get list of investor orders.
   */
  getInvestorOrders(
    investor: string,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  callStatic: {
    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Indicate whether or not the fund issuance contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (1/2)]
     * @param data Information attached to the token transfer.
     * @param operatorData Information attached to the Swaps transfer, by the operator.
     */
    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Hook function executed when tokens are sent to the fund issuance contract. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (2/2)]
     * @param data Information attached to the token transfer.
     * @param from Token holder.
     * @param operatorData Information attached to the Swaps transfer, by the operator.
     * @param partition Name of the partition.
     * @param to Token recipient.
     * @param value Number of tokens to transfer.
     */
    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Start a new subscription for a given asset in the fund issuance smart contract.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param paymentAddress Address of the payment token (only used id paymentType <> OFFCHAIN).
     * @param paymentPartition Partition of the payment token (only used if paymentType is ERC1400).
     * @param paymentPeriodLength Length of payment period.
     * @param paymentType Type of payment (OFFCHAIN | ERC20 | ERC1400).
     * @param subscriptionPeriodLength Length of subscription period.
     * @param subscriptionsOpened Set 'true' if subscriptions are opened, 'false' if not.
     * @param valuationPeriodLength Length of valuation period.
     */
    setAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: string,
      paymentPartition: BytesLike,
      fundAddress: string,
      subscriptionsOpened: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set asset value rules for a given asset.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param assetValue Asset value.
     * @param assetValueType Asset value type.
     * @param reverseAssetValue Reverse asset value.
     */
    setAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Subscribe for a given asset, by creating an order.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param orderAmount Amount of assets to purchase (used in case order type is 'amount').
     * @param orderType Order type (value | amount).
     * @param orderValue Value of assets to purchase (used in case order type is 'value').
     */
    subscribe(
      assetAddress: string,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Cancel an order.
     * @param orderIndex Index of the order to cancel.
     */
    cancelOrder(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Reject an order.
     * @param orderIndex Index of the order to reject.
     * @param rejected Set to 'true' if order shall be rejected, and set to 'false' if rejection shall be cancelled
     */
    rejectOrder(
      orderIndex: BigNumberish,
      rejected: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set assetValue for a given asset.
     * @param assetValue Units of cash required for a unit of asset.
     * @param cycleIndex Index of the cycle where assetValue needs to be set.
     * @param reverseAssetValue Units of asset required for a unit of cash.
     */
    valuate(
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Execute payment for a given order.
     * @param orderIndex Index of the order to declare as paid.
     */
    executePaymentAsInvestor(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set payment as executed for a given order.
     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
     * @param orderIndex Index of the order to declare as paid.
     */
    executePaymentAsController(
      orderIndex: BigNumberish,
      bypassPayment: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set payments as executed for a batch of given orders.
     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
     * @param orderIndexes Indexes of the orders to declare as paid.
     */
    batchExecutePaymentsAsController(
      orderIndexes: BigNumberish[],
      bypassPayment: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Settle a batch of given orders.
     * @param orderIndexes Indexes of the orders to settle.
     */
    batchSettleOrders(
      orderIndexes: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Finalize a given cycle.
     * @param cycleIndex Index of the cycle to finalize.
     */
    finalizeCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Retrieve sum of paid/unpaid settled orders for a given cycle.
     * @param cycleIndex Index of the cycle.
     */
    getTotalSettledForCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber, boolean]>;

    /**
     * Retrieve the current state of the cycle.
     * @param cycleIndex Index of the cycle.
     */
    getCycleState(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * Get the list of token controllers for a given token.
     * @param tokenAddress Token address.
     */
    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Set list of token controllers for a given token.
     * @param operators Operators addresses.
     * @param tokenAddress Token address.
     */
    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the list of price oracles for a given token.
     * @param tokenAddress Token address.
     */
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<string[]>;

    /**
     * Set list of price oracles for a given token.
     * @param oracles Oracles addresses.
     * @param tokenAddress Token address.
     */
    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get asset rules.
     * @param assetAddress Address of the asset.
     * @param assetClass Class of the asset.
     */
    getAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        string,
        string,
        string,
        boolean
      ]
    >;

    /**
     * Get the cycle asset value rules.
     * @param assetAddress Address of the asset.
     * @param assetClass Class of the asset.
     */
    getAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber, BigNumber]>;

    /**
     * Get total number of cycles in the contract.
     */
    getNbCycles(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the index of the last cycle created for a given asset class.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     */
    getLastCycleIndex(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the cycle.
     * @param index Index of the cycle.
     */
    getCycle(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        number,
        string,
        string,
        boolean
      ]
    >;

    /**
     * Get the cycle asset value.
     * @param index Index of the cycle.
     */
    getCycleAssetValue(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number, BigNumber, BigNumber]>;

    /**
     * Get total number of orders in the contract.
     */
    getNbOrders(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Retrieve an order.
     * @param index Index of the order.
     */
    getOrder(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, string, BigNumber, BigNumber, number, number]>;

    /**
     * Retrieve order amount and order value calculated based on cycle valuation.
     * @param orderIndex Index of the order.
     */
    getOrderAmountAndValue(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    /**
     * Get list of cycle orders.
     * @param index Index of the cycle.
     */
    getCycleOrders(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    /**
     * Get list of investor orders.
     */
    getInvestorOrders(
      investor: string,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;
  };

  filters: {};

  estimateGas: {
    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Indicate whether or not the fund issuance contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (1/2)]
     * @param data Information attached to the token transfer.
     * @param operatorData Information attached to the Swaps transfer, by the operator.
     */
    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Hook function executed when tokens are sent to the fund issuance contract. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (2/2)]
     * @param data Information attached to the token transfer.
     * @param from Token holder.
     * @param operatorData Information attached to the Swaps transfer, by the operator.
     * @param partition Name of the partition.
     * @param to Token recipient.
     * @param value Number of tokens to transfer.
     */
    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Start a new subscription for a given asset in the fund issuance smart contract.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param paymentAddress Address of the payment token (only used id paymentType <> OFFCHAIN).
     * @param paymentPartition Partition of the payment token (only used if paymentType is ERC1400).
     * @param paymentPeriodLength Length of payment period.
     * @param paymentType Type of payment (OFFCHAIN | ERC20 | ERC1400).
     * @param subscriptionPeriodLength Length of subscription period.
     * @param subscriptionsOpened Set 'true' if subscriptions are opened, 'false' if not.
     * @param valuationPeriodLength Length of valuation period.
     */
    setAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: string,
      paymentPartition: BytesLike,
      fundAddress: string,
      subscriptionsOpened: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set asset value rules for a given asset.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param assetValue Asset value.
     * @param assetValueType Asset value type.
     * @param reverseAssetValue Reverse asset value.
     */
    setAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Subscribe for a given asset, by creating an order.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param orderAmount Amount of assets to purchase (used in case order type is 'amount').
     * @param orderType Order type (value | amount).
     * @param orderValue Value of assets to purchase (used in case order type is 'value').
     */
    subscribe(
      assetAddress: string,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Cancel an order.
     * @param orderIndex Index of the order to cancel.
     */
    cancelOrder(
      orderIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Reject an order.
     * @param orderIndex Index of the order to reject.
     * @param rejected Set to 'true' if order shall be rejected, and set to 'false' if rejection shall be cancelled
     */
    rejectOrder(
      orderIndex: BigNumberish,
      rejected: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set assetValue for a given asset.
     * @param assetValue Units of cash required for a unit of asset.
     * @param cycleIndex Index of the cycle where assetValue needs to be set.
     * @param reverseAssetValue Units of asset required for a unit of cash.
     */
    valuate(
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Execute payment for a given order.
     * @param orderIndex Index of the order to declare as paid.
     */
    executePaymentAsInvestor(
      orderIndex: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set payment as executed for a given order.
     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
     * @param orderIndex Index of the order to declare as paid.
     */
    executePaymentAsController(
      orderIndex: BigNumberish,
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set payments as executed for a batch of given orders.
     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
     * @param orderIndexes Indexes of the orders to declare as paid.
     */
    batchExecutePaymentsAsController(
      orderIndexes: BigNumberish[],
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Settle a batch of given orders.
     * @param orderIndexes Indexes of the orders to settle.
     */
    batchSettleOrders(
      orderIndexes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Finalize a given cycle.
     * @param cycleIndex Index of the cycle to finalize.
     */
    finalizeCycle(
      cycleIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Retrieve sum of paid/unpaid settled orders for a given cycle.
     * @param cycleIndex Index of the cycle.
     */
    getTotalSettledForCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Retrieve the current state of the cycle.
     * @param cycleIndex Index of the cycle.
     */
    getCycleState(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the list of token controllers for a given token.
     * @param tokenAddress Token address.
     */
    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set list of token controllers for a given token.
     * @param operators Operators addresses.
     * @param tokenAddress Token address.
     */
    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the list of price oracles for a given token.
     * @param tokenAddress Token address.
     */
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set list of price oracles for a given token.
     * @param oracles Oracles addresses.
     * @param tokenAddress Token address.
     */
    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get asset rules.
     * @param assetAddress Address of the asset.
     * @param assetClass Class of the asset.
     */
    getAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the cycle asset value rules.
     * @param assetAddress Address of the asset.
     * @param assetClass Class of the asset.
     */
    getAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get total number of cycles in the contract.
     */
    getNbCycles(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the index of the last cycle created for a given asset class.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     */
    getLastCycleIndex(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the cycle.
     * @param index Index of the cycle.
     */
    getCycle(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the cycle asset value.
     * @param index Index of the cycle.
     */
    getCycleAssetValue(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get total number of orders in the contract.
     */
    getNbOrders(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Retrieve an order.
     * @param index Index of the order.
     */
    getOrder(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Retrieve order amount and order value calculated based on cycle valuation.
     * @param orderIndex Index of the order.
     */
    getOrderAmountAndValue(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get list of cycle orders.
     * @param index Index of the cycle.
     */
    getCycleOrders(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get list of investor orders.
     */
    getInvestorOrders(
      investor: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Indicate whether or not the fund issuance contract can receive the tokens or not. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (1/2)]
     * @param data Information attached to the token transfer.
     * @param operatorData Information attached to the Swaps transfer, by the operator.
     */
    canReceive(
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: string,
      arg3: string,
      arg4: string,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Hook function executed when tokens are sent to the fund issuance contract. [USED FOR ERC1400 TOKENS ONLY]
     * [ERC1400TokensRecipient INTERFACE (2/2)]
     * @param data Information attached to the token transfer.
     * @param from Token holder.
     * @param operatorData Information attached to the Swaps transfer, by the operator.
     * @param partition Name of the partition.
     * @param to Token recipient.
     * @param value Number of tokens to transfer.
     */
    tokensReceived(
      arg0: BytesLike,
      partition: BytesLike,
      arg2: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Start a new subscription for a given asset in the fund issuance smart contract.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param paymentAddress Address of the payment token (only used id paymentType <> OFFCHAIN).
     * @param paymentPartition Partition of the payment token (only used if paymentType is ERC1400).
     * @param paymentPeriodLength Length of payment period.
     * @param paymentType Type of payment (OFFCHAIN | ERC20 | ERC1400).
     * @param subscriptionPeriodLength Length of subscription period.
     * @param subscriptionsOpened Set 'true' if subscriptions are opened, 'false' if not.
     * @param valuationPeriodLength Length of valuation period.
     */
    setAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: string,
      paymentPartition: BytesLike,
      fundAddress: string,
      subscriptionsOpened: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set asset value rules for a given asset.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param assetValue Asset value.
     * @param assetValueType Asset value type.
     * @param reverseAssetValue Reverse asset value.
     */
    setAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Subscribe for a given asset, by creating an order.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     * @param orderAmount Amount of assets to purchase (used in case order type is 'amount').
     * @param orderType Order type (value | amount).
     * @param orderValue Value of assets to purchase (used in case order type is 'value').
     */
    subscribe(
      assetAddress: string,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Cancel an order.
     * @param orderIndex Index of the order to cancel.
     */
    cancelOrder(
      orderIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Reject an order.
     * @param orderIndex Index of the order to reject.
     * @param rejected Set to 'true' if order shall be rejected, and set to 'false' if rejection shall be cancelled
     */
    rejectOrder(
      orderIndex: BigNumberish,
      rejected: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set assetValue for a given asset.
     * @param assetValue Units of cash required for a unit of asset.
     * @param cycleIndex Index of the cycle where assetValue needs to be set.
     * @param reverseAssetValue Units of asset required for a unit of cash.
     */
    valuate(
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Execute payment for a given order.
     * @param orderIndex Index of the order to declare as paid.
     */
    executePaymentAsInvestor(
      orderIndex: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set payment as executed for a given order.
     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
     * @param orderIndex Index of the order to declare as paid.
     */
    executePaymentAsController(
      orderIndex: BigNumberish,
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set payments as executed for a batch of given orders.
     * @param bypassPayment Bypass payment (in case payment has been performed off-chain)
     * @param orderIndexes Indexes of the orders to declare as paid.
     */
    batchExecutePaymentsAsController(
      orderIndexes: BigNumberish[],
      bypassPayment: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Settle a batch of given orders.
     * @param orderIndexes Indexes of the orders to settle.
     */
    batchSettleOrders(
      orderIndexes: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Finalize a given cycle.
     * @param cycleIndex Index of the cycle to finalize.
     */
    finalizeCycle(
      cycleIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Retrieve sum of paid/unpaid settled orders for a given cycle.
     * @param cycleIndex Index of the cycle.
     */
    getTotalSettledForCycle(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Retrieve the current state of the cycle.
     * @param cycleIndex Index of the cycle.
     */
    getCycleState(
      cycleIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the list of token controllers for a given token.
     * @param tokenAddress Token address.
     */
    tokenControllers(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set list of token controllers for a given token.
     * @param operators Operators addresses.
     * @param tokenAddress Token address.
     */
    setTokenControllers(
      tokenAddress: string,
      operators: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the list of price oracles for a given token.
     * @param tokenAddress Token address.
     */
    priceOracles(
      tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set list of price oracles for a given token.
     * @param oracles Oracles addresses.
     * @param tokenAddress Token address.
     */
    setPriceOracles(
      tokenAddress: string,
      oracles: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get asset rules.
     * @param assetAddress Address of the asset.
     * @param assetClass Class of the asset.
     */
    getAssetRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the cycle asset value rules.
     * @param assetAddress Address of the asset.
     * @param assetClass Class of the asset.
     */
    getAssetValueRules(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get total number of cycles in the contract.
     */
    getNbCycles(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the index of the last cycle created for a given asset class.
     * @param assetAddress Address of the token representing the asset.
     * @param assetClass Asset class.
     */
    getLastCycleIndex(
      assetAddress: string,
      assetClass: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the cycle.
     * @param index Index of the cycle.
     */
    getCycle(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the cycle asset value.
     * @param index Index of the cycle.
     */
    getCycleAssetValue(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get total number of orders in the contract.
     */
    getNbOrders(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Retrieve an order.
     * @param index Index of the order.
     */
    getOrder(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Retrieve order amount and order value calculated based on cycle valuation.
     * @param orderIndex Index of the order.
     */
    getOrderAmountAndValue(
      orderIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get list of cycle orders.
     * @param index Index of the cycle.
     */
    getCycleOrders(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get list of investor orders.
     */
    getInvestorOrders(
      investor: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
